---
title: "gRPC란?"
seoTitle: "gRPC의 개념과 원리"
seoDescription: "gRPC가 무엇이고 왜 사용하는가?"
datePublished: Sun Nov 02 2025 14:56:29 GMT+0000 (Coordinated Universal Time)
cuid: cmhhu3jvc000102k7b6z01uup
slug: grpc
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1762066529616/da8ff483-9d8d-4f81-9be2-57c067e2de34.png
ogImage: https://cdn.hashnode.com/res/hashnode/image/upload/v1762095360605/f307d1cc-0ae5-44bc-a184-9c2e845c49b5.png
tags: microservices, programming-blogs, kafka, grpc

---

## gRPC란?

---

gRPC는 구글에서 만든 고성능 RPC 프레임워크이다. 그렇다면 RPC가 무엇인지 간단히 짚고 넘어가도록 하자.

RPC(Remote Procedure Call)은 떨어져있고 분산되어있는 컴퓨터들이 원활하게 통신을 할 수 있도록 해주는 기능이다. 이로 인해 각 컴퓨터들이 다른 컴퓨터에 있는 함수를 호출(Call)할 수 있어 RPC라 이름붙여졌다.

gRPC는 이 속성을 그대로 가지고 있는데, 주로 MSA의 서비스들간의 통신에 이용된다. 이때 각 서비스들의 프로그래밍 언어가 다르더라도 연결 할 수 있다. 이는 전 아티클에서 이야기했던 IDL(Interface Definition Language)의 지향점으로, 한 서비스가 파이썬을 사용하고, 다른 한 서비스가 Go언어를 사용하더라도 통신할 수 있도록 해준다.

각 서비스의 중간에서 gRPC는 언어 중립적으로 해석하여 서로간의 언어를 이해할 수 있도록 돕는다. 이때 사용되는 방식으로는 직렬화(serialization) 역직렬화(deserialization)가 있다. 이 방식은 각자의 언어를 조금 더 컴퓨터 지향적 언어인 바이너리 파일(바이트로 표현된 방식)로 변환하여 서로간의 이해를 돕는다.

### Protocol Buffer란?

---

gRPC에서는 이 과정을 행할때, Protocol Buffer는 구글이 개발한 데이터 직렬화 방식을 이용한다. proto 파일로 데이터 구조를 정의하면, 각 언어(Python, Java, Go 등)에 맞는 코드가 자동 생성된다.

(Protocol: 데이터를 표현하는 규약) (Buffer: 데이터를 담는 중간 형식)

이 완충작용은 .proto라는 이름의 확장자로 행하게 되는데, 이 파일을 통해서 각 서비스가 다른 서비스에 있는 함수를 호출할 수 있게 된다.

특히, 다른 함수를 호출하게 될 때는 stub. 이라는 이름의 가짜 함수를 사용하게 되는데, 이를 이용하여 원격 함수를 마치 내 컴퓨터에 있었던 함수인 것 마냥 호출할 수 있게 해준다. 서로 다른 언어를 사용하더라도 마찬가지다.

## gRPC의 장점

---

앞서 말했듯 gRPC는 각 서비스(혹은 컴퓨터)끼리 이어주는 역할을 하게 된다. 원래 각 서비스끼리 연결될 때는 텍스트 기반 방식인 Json, Xml등의 파일을 사용하게 되는데, 이는 사람이 읽기 쉬운 언어로 구성되어있다. 따라서 기계가 읽을 수 있는 방식보다는 조금 덜 효율적이다.

그래서 텍스트 기반 방식이 아니라 바이너리 방식으로 각 서비스를 이어주게 되는데, 이 바이너리 방식의 이점은 Json파일보다 더 압축적이고 빠르다는 것이다. 앞서 이야기했듯이 Json파일은 사람이 읽기 쉬운 방식으로 구성되어있기에, 계속해서 Json파일의 호출과 응답이 많아지게 될 수록 낭비되는 리소스가 커진다. 따라서, 바이너리 방식을 사용하여 좀 더 간편하고 빠르게 전달할 수 있게 된다.

또한, gRPC는 HTTP/1 기반이 아닌 HTTP/2 기반이기에 오는 이점이 또 있다. 아래는 gRPC의 코어를 설명한 것이다.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1762094996490/a0c7184a-73ec-4409-b220-4240a8d92ad1.png align="center")

이와 같이 gRPC는 HTTP/2 위에 올려져 있기 때문에 HTTP/2의 이점을 모두 흡수하게 된다.

먼저, HTTP/2는 TLS 보안 방식을 이용하여 1보다 더 안전하고, 요청과 응답을 수행하는 부분에 있어서도 더 빠르고 자유롭다. HTTP/1의 경우, 요청과 응답에 순서가 존재하는데, 마치 편지처럼 요청이 있어야 응답이 있고, 또 그 응답을 받아야 다시 요청을 보낼 수 있는 순차적인 모습을 가진다. 하지만 HTTP/2는 전화처럼 상대방이 이야기하고 있을 때도 내가 말할 수 있고, 다시 상대방이 내 말을 끊고 이야기할 수 있다. 이렇게 순차적이지 않은 HTTP/2의 속성으로 인해 응답을 기다리지 않고 요청을 보낼 수 있으며 여러 메세지를 한 번에 보낼 수도 있다.

HTTP/1.1의 경우:

* 한 번에 하나의 요청
    
* 응답만 처리 (Head-of-Line Blocking)
    
* 첫 번째 응답을 받아야 다음 요청 가능
    
* 마치 단일 차선 도로
    

HTTP/2의 경우

* 하나의 연결에서 여러 요청
    
* 응답을 동시 처리 (Multiplexing)
    
* 응답 순서와 무관하게 여러 요청 가능
    
* 마치 다차선 고속도로
    

## 결론

---

간단히 gRPC에 대하여 살펴보았는데, gRPC는 각 서비스끼리 언어가 다르더라도 빠르고 간편하고 안전한 통신을 보장하여 더 효율적으로 서비스들끼리 결합될 수 있도록 돕는다. 특히, proto 파일을 이용하여 사용자는 stub이라는 가짜 함수로 서버의 함수들을 마치 자신이 가지고 있었던 함수인 양 호출할 수 있도록 돕는다.